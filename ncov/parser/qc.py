'''
A parser for the qc metrics file generated by the COG-UK Nextflow pipeline.  The
generated file contains a header line and a data line with pre-defined columns.
'''

import re
import statistics
import argparse

def get_sample_names_from_bam():
    '''
    Get a list of samples from a directory containing BAM files.  Since the BAM
    files are the main input for all analysis, we will use these unless a list
    of sample names are provided in a config file.
    '''
    pass


def get_qc_data(file):
    '''
    A function to parse the COG-UK QC file and returns a data structure with the
    QC results.
    '''
    with open(file) as file_p:
        for line in file_p:
            # skip the header
            if re.match("^sample_name", line):
                continue
            line = line.strip()
            data = line.split(",")
    file_p.close()
    return {"sample_name" : data[0], "pct_covered_bases" : data[2], "qc_pass" : data[6]}


def get_total_variants(file):
    '''
    A function that parses the iVar variants file and returns the total number
    of variants.
    '''
    counter = 0
    with open(file) as file_p:
        for line in file_p:
            if re.match("^REGION\tPOS\tREF", line):
                # skip to the next line if header encountered
                continue
            counter += 1

    file_p.close()
    return {"total_variants" : counter}


def is_indel(variant):
    '''
    Check whether the variant from the <sample>.variants.tsv file is an indel.
    Note that indels will have a +/- in the ALT column of the file.
    '''
    return re.search(["+-"], variant)


def get_coverage_stats(file, indel=False):
    '''
    A function to calculate the depth of coverage across the genome from the
    bedtools <sample>.per_base_coverage.bed file.
    '''
    depth = []
    with open(file) as file_p:
        for line in file_p:
            if re.match("^reference_name\tstart\tend", line):
                # skip to the next line if header encountered
                continue
            line = line.strip()
            data = line.split("\t")
            depth.append(int(data[7]))
    file_p.close()
    mean_depth = statistics.mean(depth)
    median_depth = statistics.median(depth)
    return {"mean" : mean_depth, "median" : median_depth}


def create_qc_summary_line(var_file, qc_file, cov_file):
    '''
    A function that aggregates the different QC data into a single sample
    dictionary entry.
    '''
    summary = {}
    summary.update(get_total_variants(file=var_file))
    summary.update(get_qc_data(file=qc_file))
    summary.update(get_coverage_stats(file=cov_file))
    return summary

def write_qc_summary(summary):
    '''
    A function to write the QC data line to output in the order:
    * sample name
    * % bases covered
    * total mutations
    * mean sequence depth
    * median sequence depth
    * iVar QC pass
    '''
    summary_line = '\t'.join([
            summary['sample_name'],
            str(summary['pct_covered_bases']),
            str(summary['total_variants']),
            str(summary['mean']),
            str(summary['median']),
            str(summary['qc_pass'])])
    print(summary_line + '\n')


def write_qc_summary_header(header=['sample_name', \
                                    'pct_covered_bases',\
                                    'total_variants', \
                                    'mean_depth', \
                                    'median_depth', \
                                    'qc_pass']):
    '''
    Write the header for the QC summary data
    '''
    print('\t'.join(header))


def collect_qc_summary_data():
    '''
    An aggregation function to collect individual sample based QC summary data
    and create a single file with all samples.
    '''
    pass
    
    
